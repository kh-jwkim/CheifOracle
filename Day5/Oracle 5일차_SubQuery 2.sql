-- 5일차 서브쿼리(SubQuery)
-- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문
-- 메인 쿼리가 서브 쿼리를 포함하는 종속적인 관계
-- 서브쿼리는 반드시 소괄호로 묶어야 함
-- 서브쿼리 안에 ORDER BY는 지원 안되니 주의!!

DESC EMPLOYEE;
-- 예제1
-- 전지연 직원의 관리자 이름을 출력하세요.
-- 서브쿼리 없이 구현
SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME LIKE '전지연'; -- 결과값 214 출력
SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_ID = 214;

-- 서브쿼리로 구현
SELECT EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID = (SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME LIKE '전지연');

-- [전 직원의 평균 급여보다 많은 급여를 받고 있는 직원의 사번, 이름, 직급코드, 급여를 조회하세요.]
-- 서브쿼리를 쓰지 않는 경우
-- 직접 평균값 계산해서 구하고
SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE; --3047662
-- 평균값을 WHERE절에 넣어줘야 한다...
SELECT EMP_ID "사번", EMP_NAME "이름", JOB_CODE "직급코드", SALARY "급여"
FROM EMPLOYEE
WHERE SALARY>3047662;

-- 서브쿼리를 쓰는 경우
SELECT EMP_ID "사번", EMP_NAME "이름", JOB_CODE "직급코드", SALARY "급여"
FROM EMPLOYEE
WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE);



-- 1.2 서브쿼리의 종류
-- 1.2.1. 단일행 서브쿼리
-- 1.2.2. 다중행 서브쿼리
-- 1.2.3. 다중열 서브쿼리
-- 1.2.4. 단일행 서브쿼리
-- 1.2.5. 상(호연)관 서브쿼리
-- 1.2.6. 스칼라 서브쿼리


-- 1.2.2 다중행 서브쿼리
-- 송종기나 박나라가 속한 부서에 속한 직원들의 전체 정보를 출력하세요.
SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '송종기'; -- D9
SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '박나라'; -- D5
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE IN ('D9','D5');

-- 단일행 서브쿼리로 쿼리문을 길게 썼을 때
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '송종기')
OR DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '박나라');

-- IN 연산자는 서브쿼리의 결과값이 여러 열이어도 받아서 처리 할 수 있다!
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','박나라'));


-- @실습문제1
-- 차태연, 전지연 사원의 급여등급과 같은 사원의 직급명, 사원명을 출력하세요.
SELECT JOB_NAME "직급명", EMP_NAME "사원명"
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
WHERE SAL_LEVEL IN (SELECT SAL_LEVEL FROM EMPLOYEE WHERE EMP_NAME IN ('차태연','전지연'));


-- @실습문제2
-- ASIA1지역에 근무하는 직원의 정보(부서코드, 사원명)를 출력하세요.
DESC DEPARTMENT;
DESC LOCATION;
SELECT * FROM LOCATION;
SELECT DEPT_CODE "부서코드", EMP_NAME "사원명"
FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
JOIN LOCATION ON LOCATION_ID = LOCAL_CODE
WHERE LOCAL_NAME = UPPER('Asia1')
ORDER BY DEPT_CODE ASC;

-- 서브쿼리를 쓰는 경우
SELECT DEPT_CODE "부서코드", EMP_NAME "사원명"
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_ID FROM DEPARTMENT WHERE LOCATION_ID IN (SELECT LOCAL_CODE FROM LOCATION WHERE LOCAL_NAME = UPPER('Asia1')))
ORDER BY DEPT_CODE ASC;


-- 1.2.5. 상(호연)관 서브쿼리
--  - 메인쿼리의 값이 서브쿼리에 사용되는 것
--  - 메인쿼리의 값을 서브쿼리에 주고 서브쿼리를 수행한 다음 그 결과를 다시 메인 쿼리로 반환해서 수행하는 것
--  - 상호연관 관계를 가지고 실행하는 쿼리이다.
SELECT * FROM EMPLOYEE WHERE 1=1; -- WHERE절이 TRUE 이므로 출력
SELECT * FROM EMPLOYEE WHERE 1=0; -- WHERE절이 FALSE 이므로 출력 안됨
SELECT 1 FROM DUAL; -- RESULT SET으로 1 출력(값이 있으니 TRUE)
SELECT * FROM EMPLOYEE WHERE EXISTS (SELECT 1 FROM DUAL); -- RESULT SET이 존재 하기 때문에 결과 출력
SELECT 1 FROM EMPLOYEE WHERE EMP_ID = '2000'; -- RESULT SET이 비어있음(값이 없으니 FALSE)
SELECT * FROM EMPLOYEE WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE EMP_ID = '2000'); -- RESULT SET이 존재하지 않기 때문에 결과 출력 X

SELECT * FROM EMPLOYEE E WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE MANAGER_ID = E.EMP_ID);




-- SELECT 실행순서
-- FROM - WHERE - SELECT
--          GROUP BY - HAVING
--                  ORDER BY


-- 실습예제1
-- 부하직원이 한명이라도 있는 직원의 정보를 출력하시오.
SELECT * FROM EMPLOYEE E WHERE EXISTS (SELECT * FROM EMPLOYEE J WHERE MANAGER_ID = E.EMP_ID); -- 위의 예제 그대로 가져다 쓰면 되는거 아닌가...?

SELECT 1 FROM EMPLOYEE WHERE MANAGER_ID = EMP_ID;



-- @실습문제1
-- 가장 많은 급여를 받는 직원을 출력하시오.
-- 단일행 서브쿼리로 구현
SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE);

-- 상관쿼리로 구현
SELECT 1 FROM EMPLOYEE WHERE SALARY > 8000000;
SELECT 1 FROM EMPLOYEE WHERE SALARY > 6000000; -- ...
-- SALARY가 최대값일 때 전체 데이터의 SALARY 중 그것보다 더 큰 값이 없음...
SELECT * FROM EMPLOYEE E WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEE J WHERE SALARY > E.SALARY);   -- NOT EXISTS로 최대값인 조건을 찾았다


-- @실습문제2
-- 가장 적은 급여를 받는 직원을 출력하시오.
SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

SELECT * FROM EMPLOYEE E WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEE J WHERE SALARY < E.SALARY);



-- @실습문제3
-- 심봉선과 같은 부서의 사원의 부서코드, 사원명, 월평균급여를 조회하시오.
SELECT DEPT_CODE, EMP_NAME, (SELECT FLOOR(AVG(SALARY)) 
FROM EMPLOYEE GROUP BY DEPT_CODE 
HAVING DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '심봉선')) 
FROM EMPLOYEE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '심봉선');

-- 1. 심봉선과 같은 부서코드를 가진 행만 출력
-- - 검증쿼리
--SELECT 1 FROM EMPLOYEE WHERE EXIST--
SELECT 1 FROM EMPLOYEE WHERE E.DEPT_CODE LIKE (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '심봉선');
-- - 메인쿼리
SELECT DEPT_CODE, EMP_NAME
FROM EMPLOYEE E WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE DEPT_CODE = E.DEPT_CODE AND EMP_NAME = '심봉선');

-- 2. 월평균급여 출력
-- - 메인쿼리에 월평균급여 추가

SELECT DEPT_CODE "부서코드", EMP_NAME "사원명", 
(SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY DEPT_CODE HAVING DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '심봉선')) "부서 월평균 급여"
FROM EMPLOYEE E WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE E.DEPT_CODE LIKE (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '심봉선'));

SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE;
SELECT DEPT_CODE "부서코드", EMP_NAME "사원명", 
(SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE J WHERE EXISTS(SELECT 1 FROM EMPLOYEE WHERE J.DEPT_CODE LIKE (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '심봉선'))) "부서 월평균 급여"
FROM EMPLOYEE E WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE E.DEPT_CODE LIKE (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME LIKE '심봉선'));



-- @실습문제4
-- 직급이 J1, J2, J3이 아닌 사원중에서 자신의 부서별 평균급여보다 많은 급여를 받는
-- 직원의 부서코드, 사원명, 급여, (부서별 급여평균) 정보를 출력하시오.
SELECT DEPT_CODE "부서코드", EMP_NAME "사원명", SALARY "급여", (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY DEPT_CODE HAVING DEPT_CODE = E.DEPT_CODE) "부서별 평균급여"
FROM EMPLOYEE E 
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE HAVING DEPT_CODE = E.DEPT_CODE);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='선동일';
SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE WHERE DEPT_CODE = 'D6';



-- 1.2.6. 스칼라 서브쿼리








