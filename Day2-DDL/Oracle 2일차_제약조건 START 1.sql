CREATE TABLE USER_NO_CONSTRAINT (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(30),
    USER_NAME VARCHAR2(30),
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DROP TABLE USER_NO_CONSTRAINT;

SELECT * FROM USER_NO_CONSTRAINT;

-- INSERT INTO ${TABLE_NAME}(COLUMN1, COLUMN2, ...) VALUES(FIELD1,FIELD2,...); 잘 안외워지니 이것도 연습 필요
-- 1, khuser01, pass01, 일용자, 남, 01012345678, khuser01@test.com
INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(1, 'khuser01', 'pass01', '일용자', '남', '01012345678', 'khuser01@test.com');
INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(1, 'khuser01', 'pass01', '일용자', '남', '01012345678', 'khuser01@test.com');
INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(1, 'khuser01', 'pass01', '일용자', '남', '01012345678', 'khuser01@test.com');

ROLLBACK;

COMMIT;

--제약조건 없어서 그대로 입력 가능
INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(null, null, null, null, null, null, null);

--여기선 출력해도 전부 (null)로 나오지만 그냥 null과 ''는 다르다!!
INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(null, null, '', null, null, null, null);

INSERT INTO USER_NO_CONSTRAINT(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(2, 'khuser02', null, null, null, null, null);






CREATE TABLE USER_NOTNULL (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL,      -- 필드값 선언 오른쪽에 NOT NULL 적은것이 COLUMN LEVEL 방식
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

SELECT * FROM USER_NOTNULL;

-- NOT NULL 속성이 있는 필드에 NULL로 값을 줘서 ROW를 작성할 때
INSERT INTO USER_NOTNULL(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(1, 'khuser01', null, null, null, null, null);

-- NOT NULL 필드를 채워줬을 때
INSERT INTO USER_NOTNULL(USER_NO, USER_ID, USER_PWD, USER_NAME, USER_GENDER, USER_PHONE, USER_EMAIL)
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);




CREATE TABLE USER_UNIQUE (
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE,      -- 필드값 선언 오른쪽에 NOT NULL 적은것이 COLUMN LEVEL 방식
    USER_PWD VARCHAR2(30) UNIQUE,
    USER_NAME VARCHAR2(30) UNIQUE,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

--UNIQUE 제약 조건으로 중복은 막았으나 NULL은 막지 못한 상태
SELECT * FROM USER_UNIQUE;

-- 같은값 2번 중복 입력 시
INSERT INTO USER_UNIQUE
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);
INSERT INTO USER_UNIQUE
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);



CREATE TABLE USER_PRIMARY_KEY (
    USER_NO NUMBER UNIQUE NOT NULL,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10),
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DROP TABLE USER_PRIMARY_KEY;

SELECT * FROM USER_PRIMARY_KEY;

-- UNIQUE NOT NULL 속성의 필드값으로 NULL을 줬을 때
INSERT INTO USER_PRIMARY_KEY
VALUES(1, null, 'pass01', '일용자', null, null, null);

INSERT INTO USER_PRIMARY_KEY
VALUES(1, 'khuser01', 'pass01', '일용자', null, null, null);
INSERT INTO USER_PRIMARY_KEY
VALUES(2, 'khuser02', 'pass02', '이용자', null, null, null);
INSERT INTO USER_PRIMARY_KEY
VALUES(3, 'khuser01', 'pass03', '삼용자', null, null, null);   -- 중복값일때의 에러메시지 체크!
INSERT INTO USER_PRIMARY_KEY
VALUES(3, null, 'pass03', '삼용자', null, null, null);         -- NULL일때의 에러메시지 체크!





CREATE TABLE USER_CHECK (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')),   --CHECK 제약조건 설정
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

DROP TABLE USER_CHECK;

INSERT INTO USER_CHECK
VALUES(1, 'khuser01', 'pass01', '일용자', 'M', null, null);
INSERT INTO USER_CHECK
VALUES(2, 'khuser02', 'pass02', '이용자', 'm', null, null);    --대소문자도 구분된다!!
INSERT INTO USER_CHECK
VALUES(3, 'khuser03', 'pass03', '삼용자', 'Male', null, null);

SELECT * FROM USER_CHECK;






CREATE TABLE USER_DEFAULT (
    USER_NO NUMBER UNIQUE,
    USER_ID VARCHAR2(20) PRIMARY KEY,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')), 
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE  --데이터 입력 시 DEFAULT를 입력하면 우측의 SYSDATE 결과로 저장
);
DROP TABLE USER_DEFAULT;

INSERT INTO USER_DEFAULT
VALUES(1, 'khuser01', 'pass01', '일용자', 'M', '01012345678', 'khuser01@test.com', '24/06/14');
INSERT INTO USER_DEFAULT
VALUES(2, 'khuser02', 'pass02', '이용자', 'M', '01012345678', 'khuser02@test.com', SYSDATE+7);
INSERT INTO USER_DEFAULT
VALUES(3, 'khuser03', 'pass03', '삼용자', 'M', '01012345678', 'khuser03@test.com', DEFAULT);

SELECT * FROM USER_DEFAULT;

--제약조건
-- 1. NOT NULL : NULL이 들어가지 않게함
-- 2. UNIQUE : 중복이 되지 않게함
-- 3. PRIMARY KEY : 중복이 안되고 NULL이 되지 않도록 함
-- 4. CHECK : 지정된 값만 저장되도록 함
-- 5. DEFAULT : 지정된 함수나 표현식으로 실행되도록 함
-- 6. FOREIGN KEY(외래키) : 


CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
SELECT * FROM USER_GRADE;
--DELETE FROM USER_GRADE;
INSERT INTO USER_GRADE VALUES(10, '일반회원');
INSERT INTO USER_GRADE VALUES(20, '우수회원');
INSERT INTO USER_GRADE VALUES(30, '특별회원');
INSERT INTO USER_GRADE VALUES(40, 'VIP 회원');

DELETE FROM USER_GRADE WHERE GRADE_CODE = 30;

CREATE TABLE USER_FOREIGN_KEY(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')), 
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50),
    USER_DATE DATE DEFAULT SYSDATE,
    --USER_GRADE 테이블의 GRADE_CODE 값으로만 참조하겠다
    --ON DELETE SET NULL 은 참조값 삭제 시 NULL로 바꾸겠다
    --GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE SET NULL
    GRADE_CODE NUMBER REFERENCES USER_GRADE(GRADE_CODE) ON DELETE CASCADE
);

DROP TABLE USER_FOREIGN_KEY;

SELECT * FROM USER_FOREIGN_KEY;

-- USER_FOREIGN_KEY에 있는 GRADE_CODE는 USER_GRADE의 GRADE_CODE가 가지고있는 10, 20, 30만 넣어야 한다
-- 10, 20, 30 외의 값인 40은 입력 불가능!
INSERT INTO USER_FOREIGN_KEY
VALUES(1, 'khuser01', 'pw01', '일용자', 'M', '01012345678', 'khuser01@test.com', DEFAULT, 10);
INSERT INTO USER_FOREIGN_KEY
VALUES(2, 'khuser02', 'pw02', '이용자', 'M', '01012345678', 'khuser02@test.com', DEFAULT, 20);
INSERT INTO USER_FOREIGN_KEY
VALUES(3, 'khuser03', 'pw03', '삼용자', 'M', '01012345678', 'khuser03@test.com', DEFAULT, 30);
INSERT INTO USER_FOREIGN_KEY
VALUES(4, 'khuser04', 'pw04', '사용자', 'M', '01012345678', 'khuser04@test.com', DEFAULT, 40);

DELETE FROM USER_GRADE WHERE GRADE_CODE = 40;

INSERT INTO USER_GRADE VALUES(40, 'VIP 회원');




CREATE TABLE GRADE_POINT(
    GRADE_POINT NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO USER_POINT VALUES(10, '일반등급');



---------------------------------------------------------------------------------------------


-- 테이블명 : SHOP_MEMBER
-- 저장해야할 데이터 : 1, khuser01, pass01, 일용자, M, 01012345678, khuser01@test.com

CREATE TABLE SHOP_MEMBER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE NOT NULL,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30) NOT NULL,
    USER_GENDER VARCHAR2(10) CHECK(USER_GENDER IN('M', 'F')), 
    USER_PHONE VARCHAR2(30),
    USER_EMAIL VARCHAR2(50)
);

INSERT INTO SHOP_MEMBER
VALUES(1, 'khuser01', 'pass01', '일용자', 'M', '01012345678', 'khuser01@test.com');
INSERT INTO SHOP_MEMBER
VALUES(2, 'khuser02', 'pass02', '이용자', 'M', '01012345678', 'khuser02@test.com');

SELECT * FROM SHOP_MEMBER;
COMMIT;



-- 테이블명 : SHOP_BUY
-- 저장해야할 데이터 : 1, khuser01, 농구화, 24/06/14

CREATE TABLE SHOP_BUY(
    BUY_NO NUMBER PRIMARY KEY,
    --USER_ID VARCHAR2(20) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE CASCADE NOT NULL, -- USER_ID 필드에 NULL을 넣을 수 없고 참조값 삭제 시 해당 튜플 삭제
    USER_ID VARCHAR2(20) REFERENCES SHOP_MEMBER(USER_ID) ON DELETE SET NULL, -- 참조값 삭제 시 USER_ID 필드를 NULL로 변경
    PRODUCT_NAME VARCHAR2(30) NOT NULL,
    REG_DATE DATE DEFAULT SYSDATE
);
-- SHOP_BUY의 USER_ID는 SHOT_MEMBER의 USER_ID가 가지고 있는
-- khuser01, khuser02 등... 만 넣을 수 있다
DROP TABLE SHOP_BUY;

SELECT * FROM SHOP_BUY;

INSERT INTO SHOP_BUY
VALUES(1, 'khuser01', '농구화', DEFAULT);
INSERT INTO SHOP_BUY
VALUES(2, 'khuser02', '농구화', DEFAULT);

COMMIT;



-- 외래키 FOREIGN KEY
-- 자식테이블이 부모 테이블이 가지고 있는 컬럼의 필드값으로만 INSERT하도록 하는 것
-- 참조 무결성을 보장하는 제약조건임
-- 컬럼 레벨 : REFERENCES ${부모테이블}(${컬럼명}) 삭제 옵션(ON DELETE SET NULL, ON DELETE CASECADE)

-- 외래키 삭제옵션 (부모테이블의 데이터 삭제 시도시 자식 테이블의 데이터를 처리하는 방법)
-- 1. 기본 옵션 ON DELETE RESTRICTED
-- 2. 연관된 모든 것 삭제 옵션 : ON DELETE CASCADE
-- 3. NULL로 만드는 삭제 옵션 : ON DELETE SET NULL